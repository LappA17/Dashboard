import express, { Request, Response, NextFunction } from 'express'
import { userRouter } from './src/users/users.js'

const port = 8000
const app = express()

userRouter.use((req, res, next) => {
	console.log('Обработчик роута ', Date.now())
	next()
})
app.use((req, res, next) => {
	console.log('Время ', Date.now())
	next()
})

app.get('/hello', (req, res) => {
	res.end()
})

app.use('/users', userRouter)

app.use((err: Error, req: Request, res: Response, next: NextFunction) => {
	console.log(err.message)
	res.status(500).send(err.message)
})

app.listen(port, () => console.log(`Server started on: ${port}`))

/*
listen - наш сервер не завершает процес из-за нашего обработчика он начинает крутится в цикле
res - в рамках получение запроса мы уже генерим ответы
Если мы сейчас зайдем в постман или инсомнию и в get запрос передадим наш http://localhost:8000 то получим hello world

Но почему бы нам не писать чисто на Ноде без Экспресса ?
Проблемы начинаются тогда, когда мы начинаем работать с большими проектами и нам нужен большой сервер
У большого АПИ - много роутов
Как мы можем определить роут на который постучался пользователь - res.url
Кроме этого он может стучатся разными метода и мы можем в реквесте посмотреть методы req.method
По-этому когда наше приложение разростается, и нам к примеру нужно на роут hello методом get ответить hello world, а на какой-то другой роут что-то другое то нам нужно с помощью к примеру switch(req.method) case 'GET':
соотвественно если метод GET то нужно внутри сделать еще один switch, потому что реквест url может быть разным !
switch(req.method){
    case 'GET':
        switch(req.url) {
            case '/hello':
                // и если req.url равен hello к примеру то мы уже устанавливаем нужный нам статус
                res.statusCode = 200
                res.setHeader('Content-Type', 'text/plain')
                res.end('Hello world!')
            break
        }
        break
}
Теперь на http://localhost:8000/hello мы получим ответ Hello world!

А теперь представь что у нас на сервере больше 50 апишек и сколько таких свитчкейсов будет, эту проблему решает экспрес

//express
Порт мы уже можем убрать const host = '127.0.0.1'
Что бы создать наше приложение нам нужно вызвать фцию express которое импортируется из экспресса
В рамках этого приложения мы можем указать роуты на которые наше приложение будет отправлять и создавать сам сервер который мы делали раньше с помощью listen
Что бы слушать запросы нужно обратиться к app.listen()
И указать порт плюс колббек

Теперь нам осталось только переделать Роут, именно здесь мы будем экономить свое время и не писать switch case
app. и здесь мы можем обрабатывать любые методы, всё что мы хотим
Дальше мы указываем роут который мы хотим обработать
и коллбек с req, res
app.get('/hello', (req, res) => {
    res.send('Привет')
})
Вот так мы обработали наш роут, без свитч кейс

// Маршрутизация
Представим что нам нужно обработать пост запрос, мы делаем app.post() и все дальше тоже самое
Другие запросы работают аналогично: putt, delete, patch

Так же у нас есть app.all()
Это по сути мидлвеер который говорит что при запросе любым методом нашего hello - мы должны включить дополнительные обработчики, при том что кроме req и res он принимает еще и next
next - это функция которая передает управление следующему по списку обработчику
Представим что мы делаем POST на hello, если поставим перед нашим app.post -> app.all то сначала запрос попадёт в обработчик в котором будет указанно app.all(/hello) и если мы дальше вызовем фцию next то он будет передавать дальше уже на сам app.post(/hello)
Фактически это реализации мидлвеер, которая внедряется между самим запросов и роутом нужного типа, при этом нам не обязательно можем передавать управления следующему обработчику с помощью next, мы можем кинуть ошибку или сделать что-то еще
app.all('/hello', (req, res) => {
    console.log('All')
    next()
})
Если мы так оставим то ничего работать не будет, почему ?
Потому что порядок задания роутов определяет порядок их обработки
С одной стороны это удобно что нам не нужно дополнительно указывать какие-то порядки как мы хотим триггерить наши роуты, с другой стороны это неудобство со стороны соглашения, что мы говорим если наш all к примеру определен раньше нашего get то мы сможем вызввать аll, если раньше get то нет, потому что get первый указан по коду

Роуты:
1 Так же мы в роут можем передать знак вопроса /hel?lo - это значит что мы попадем по Роуту либо hello либо helo потому что та буква перед которой стоит знак вопроса становится в роуте необязательной
2 По аналогии можем передать + hel+lo это значит что после плюса будет неограниченно число букв, то-есть будет валидно hello, helllllllo и тд
Это будет полезно когда нам нужно сделать какой-то обработчик на несколько роутов, к примеру на многие роуты нужно наложить одну фцию
3 hel*lo * означает что не только hello валидно а и helasdadsasdlo, то-есть любой символ и неограниченно их число
4 можем сгрупировать he(la)?lo - так мы скажем что група (la) будет необязательна, то-есть будет работать как и helo, так и helalo
Мы можем делать такие комбинации со всеми
5 Так же можем использовать reg exp к примеру /.*a$/ - это означает что мы можем попасть на любые символы но заканчиваться должна на а
Вообще мы можем обрабатывать любые строки с помощью рег експов и такое случается когда нужно обработать тяжелый паттерн

Мы можем объявить много callback
const callback = (req, res, next) => {
    console.log('CB')
    next()
}
То-есть мы после all создали этот коллбек, после алл мы попадаем в этот коллбек, передаем его аргументов в финальный гет app.get('/hello', callback, (req, res), заметь что мы в этом коллбек так же вызываем next()
Причем количество этих коллбеков может быть неограниченно
app.get('/hello', [callback, callback2, callback3,  (req, res) => {
    res.send('Привет')
}])

Экспресс предоставляет нам удобнуюз возможность записи наших роутов
app.route('/user')
    .get('/hello', callback, (req, res) => {
        res.send('Привет')
    })
    .post(/hello, callback, (req, res) => {
        res.send('Привет post')
    })
Такая запись позволяет нам на одну сущность сделать различные методы

//Ответы клиенту
1 Мы можем отправлять не только строки, а и json res.send({ message: true})
2 Так же статус res.status(201).send({})
3 Мы можем отправлять json не только методом send но и json - res.status(201).json({}) тогда мы четко говорим что работает только с json
4 Можем отправить ссылку на скачивания файла - res.download('/test.pdf', 'customName') который принмает в себя путь до того что нужно скачать, а вторым аргументов можем задать ему кастомное имя
5 res.redirect(301, 'https://some-domen') - представим что пользователь нажимает на купон и его должно редиректнуть на сайт купонатора, редирект принимает статус 301 - стадарт и вторым домен

Заголовки
Когда мы отправляем какой-то ответ то нам часто нужно добавлять какуе-то информацию в заголовок, к примеру явно задать контент тайп, добавить какой-то локейшен, прикрепить линксины, то-есть все что мы хотим делать с нашим хедором
По-этому когда мы делаем send() - res.send('Привет') мы можем перед этим мемотодом вызвать следующие
set
res.set('Content-Type', 'text/plain') //устанавливает параметр нашего заголовка 'Content-Type', 'text/plain', то-есть мы сказали что КонтентТайп будет текстплейн
res.send('Привет')
Таким образом мы можем задать любой другой заголовок для нашего ответа

append
Позволяет добавить какой-то новый заголовок
res.append('Warning', 'code') таким образом мы можем создавать кастомные заголовки и оповещать нашего пользователя

type
Так же мы можем создавать тип нашего ответа
res.type() и тут будет html, json, application/json, png
res.type('application/json') -> будет форсить контент тайп на апликейшен json и теперь у нас будет не привет обычным текстом в ответе а контент-тайп аликейшен джсон, но если мы этот заголовок уберем то мы получаем то что идет по умолчанию - plain text

location
Можем задать такой заголовок как location
res.location() полезно для гугла

links - для включения линков в наш хедер
res.links({
    next: 'nextLink', // в некст передаем нужный нам линк
    lastLink: и так далее
})

Cookies - кукис у нас передается сс каждым запросом пользователя
res.cookie('token', 'someTokendasdsadadssad', {
    domain: '',
    path: '/',
    secure: true,
    expires:  600000
})
Передаем имя токена, сам токен и доп параметры, secure - безопасно ли, expires:  600000 - когда перестанет быть валидной и испарится
Куки сами по себе крайне полезны, потому что по куки мы можем авторизовывать пользователя каждый раз когда он приходит
res.clearCookie('token') - очистит куки, туда передаем имя для очистки кука и опционально можем передать вторым аргуметов { path }
К примеру нам нужно чистить кук после разлогина пользователя

Если мы ничего не будем отвечать то наш то-есть просто оставим
app.get('/hello', (req, res) => {})
То будет бескончено грузится и это никак не означает для экспреса что мы что-то должны ответить
По-этому если мы ничего не хотим отвечать то нам нужно просто ответить res.status(404).end()
И вот именно метод end завершит нашу обработку
То-есть что бы роут розрезолвился нужно всегда добавлять что-то в ответ

//Router
Нужно понимать что наш роутинг будет постоянно рости и развиваться, дополнение продуктов, время работы магазина и тд и нужно понимать что наш корневой файл будет рости потому что нужно будет делать get на один метод, post на второй и так далее
В Экспрессе часто пишут гавнокод и вся реализация запросов впихана в одном файле

После того как мы импортировали userRouter мы можем привязать с помощью use
app.use('/users', userRouter) в рамках этого use мы передаем корневой роут и сам роутер который в дальнейшим будет обрабатывать
Таким же образом мы будем привязывать и мидлвееры и экцепшины всякие
По сути мы говорим что когда пользователь стучится по users он попадет в обработку этого роута -> в наш файл users.js
и если он передатс слеш user слеш логин то он попадет в роутер с логином, а если передаст /user/register то в регистер
Тем самым мы декомпозировали приложение, разбив его на несколько почти отделимых частей где каждый из них имеет отделимиый роутер
Почему почти потому что приложение будет нетестируемым так как связанно с корневым апом

// Midleware - промежуточные обработчики
Мы можем задать мидлвеер не только на конкретный руот, а даже на всё приложение
К примеру нам нужно сделать в рамках приложения одну входящую точку где будут логироваться все наши запросы
Так же мы можем определить роут не только на увроне отдельного приложения, а и на уровне отдельного роута
userRouter.use((req, res, next) => {
    console.log('Обработчик роута ', Date.now())
    next()
})

app.use('/hello', (req, res, next) => позволит нам задать обработчик для всех запросов связанных с hello

ERRORS
Мидлвееры подходят для обработки ошибок
Если мы не будем их обрабатывать, а просто напишем throw new Error()
То мы увидим текст который мы туда передали плюс куча непонятного текста для пользователя и это ужасный юзер экспириенс
Теперь представим что нам нужно нормально обработать ошибки и на ошибку авторизации кидать не 500, а 401
ОЧЕНЬ ВАЖНО ! Обработчик ошибки всегда добавляет в самом конце после всех объявлений use
Cам обработчик ошибки очень похож на обычный use, но первым параметрам получает error -> (err, req, res, next)
В таком случае нам часто не нужно использовать next(), а мы будем просто отвечать каким-то статусом

Высновок:
Мы делаем какой-то запрос -> сначала отрабатывают обработчики на уровне приложения который мы задали -> затем мы вызываем next() и это уже будет переданно в обработчик конкретного роутера -> если он прошел обработчик роута то мы попадаем в конкретный роутер где get и в этом роуте мы можем задать конкретный массив где будут конкретные обработчики для этого роута и все они будут работать исключительно с этим роутом -> и если мы выходим с ошибкой то мы попадаем в обработчик app.use с ошибкой -> а если ошибки нет то просто что-то отвечаем пользователю
*/
