import { compare, hash } from 'bcryptjs';

export class User {
	private _password: string;

	constructor(
		private readonly _email: string,
		private readonly _name: string,
		passwordHash?: string,
	) {
		if (passwordHash) this._password = passwordHash;
	}

	get email(): string {
		return this._email;
	}

	get name(): string {
		return this._name;
	}

	get password(): string {
		return this._password;
	}

	public async setPassword(pass: string, salt: number): Promise<void> {
		// будем хешировать пароль
		this._password = await hash(pass, salt);
	}

	public async comparePassword(pass: string): Promise<boolean> {
		return compare(pass, this.password); //будет сравнивать пароль с хешированным паролем, бо в конструкторе мы паролю присвоили хешированный пар
	}
}

/*
//entity
что такое ентити ? в концепции ддт или клиенткода или роберта мартина, то енти - это по сути единица которая описывает реальный бизнес Объект, в качестве какого-то класса, у которого могут быть свои методы, свои свойства и там внутри будут зашиты его бизнес описания и бизнес логика

User - это будет наша бизнес единица пользователя
у юзера должен быть емейл, пароль и имя

Мы создает _email приватный и для него getter таким образом мы уже не сможем менять этот емейл, а работать только с тем что у нас есть
А если нам нужно будет модифицировать какие-то поля то мы лучше просто сделаем для них setter что бы разнести set и get

Пароль
private _password: string; - мы пароль делаем отдельно, не в конструкторе. Потому что мы пароли воткрытом виде в базе данных хранить не будем. 
Нам нужно хешировать пароль, потом сравнивать с исходным максимум, но не как не держать его в открытом доступе

Сделаем метод setPassword, потому что setter не может быть асинхронным 

хешировать будем с помощью bcrypt js 
this._password = await hash(pass, 10); - вторым параметром передаеём соль, пока что 10 но в будущем будем передавать соль которая хранитца в конфигурации приложения приватно

И так, ентини у нас относится для инкапсуляции бизнес логики, которая у нас относится к объекту реального мира который мы описываем. 
ЕНТИТИ должна быть максимально отделена от других частей нашего приложения что бы мы могли изолированно видеть бизнес логику которая у нас там присутсвует
*/

//Разделим теперь по слоям то что у нас отвечает за роутинг(а именно контроллер) и то что отвечает за бизнесс логику - это сервис. По-этому наша задача сделать юзер-сервис и вынести туда логику работы с пользователем туда, а здесь оставить только логику для работы с контроллером
