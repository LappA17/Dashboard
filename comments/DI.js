/*
Dependency Injection - процесс предоставляемый внешней зависимости програмному компоненту
const logger = new LoggerService()
const app = new App(
    new UserController(logger)
    new ExeptionFilter(logger)
)
Такой DI предоставит нам возможность избавится от инстанциирования тех или иных классов внутри реализации нашего Логгера, Аппа и так далее и использовать внешнюю передачу зависимостей, что бы мы могли в будущем отделить этот програмный Компонент и его отдельно протестировать
Эта передача через конструктор - это один из простых вариантов DI

Через конструктор:
export class B {}
export class A {
    private a: B
    constructor(a: B) {
        this.a = a
    }
}

Через метод:
export class B {}

export class A {
    run(a: B) {

    }
}
Если нам этот B нужен исключительно в одном методе, то мы можем спокойно не передавать его в конструктор и не сохранять на уровне всего класса, а работать с ним инстенциально в рамках одного метода. Таким образом он создаться всего лишь один раз только для метода

Compossion Root
Точка сбора зависимостей
сonst logger = new LoggerService()
const app = new App(
    new UserController(logger)
    new ExeptionFilter(logger)
)
await app.init()
Всё что у нас находится в bootstrap - это Compossion Root, здесь мы строим дерево зависимостей

Схема простого DI
    class A  <-- uses -->  class B 
То-есть мы напрямую вставляет класс Б либо через метод либо через конструктор

DI с интерфейсами
class A uses--> interface B <--implements class B
Мы говорим что нашему классу А нужен определенный класс Б удолитворяющий следующему интерфейсу. Благодаря этому мы можем легко подменять логгеры
Пример с нашим ILogger

Inversion of control и DIP
Inversion of control(инверсия управления) - это ПРИНЦИП, где каждый компонент системы должен быть как можно более изолирован от других, не полагаясь в своей работе на детали конкретной реализации других компонентов.
Наш пример с ILogger идеально подходит, потому что с помощью него мы изолировали и никак не полагаемся на то как логгер будет реализован, а только какие там будут свойства и методы

Dependency injection principle(инверсия зависимостей) - Модуль верхних уровней не должны импортировать сущности из модулей нижних уровней(у нас не должны нижнии сервисы или там репозитории использовать более верхнии сущности типа самого нашего App. Представим что мы бы здесь useRoutes прокидывали во внутрь полноценный инстенс App во внутрь вместо this.app.use то мы бы нарушали этот принцип, потому что мы передаем потому что то что написанно с точки зрения верхних модулей типа Апп мы передаем вниз). Оба типа модулей должны зависеть от абстракций. Абстракции не должны зависеть от деталей, а детали должны зависеть от абстракций

Детально:
Принципы --> Inversion of control , Dependency injection principle

Паттерн --> Dependency injection

IoC(инвершен оф контрол) container - реализация

Теперь посмотрим на реализацию этого контейнеру и почему он прощу и удобней
DI с IoC
У нас есть class A, когда мы начинаем наше приложение то он регистрируется в контейнере, мы знаем что у нас есть этот класс А, что он регистрируется по какому-то уникальному токену и мы знаем что этот класс удолитворяет какому-то интерфейсу А
Тоже самое происходит с class B - тоже регистрируется в контейнере
И теперь когда нам нужно в класс A докинуть нашу зависимость в виде интерфейса, то контейнер за нас создает инстенс класса B, после этого этот инстенс класса Б внедряется как зависимость в наш класс А, потому что он будет удолитворять интерфейсу B
Аналогично контейнер нам создаст класс А
По-сути у нас есть центральная точка управления которая за нас делает создания наших классов и при этом при создание этих классов, она понимает какие зависимости им нужны, создает сначала эти зависимости и передает их внутрь
Благодаря этому мы избоавляемся от Compossion Root который мы делали руками и фактически Compossion Root находится внутри контейнера и его реализация от нас скрыта, но благодаря этому мы получаем удобный DI без доп строчек кода которые нужно делать руками
*/
